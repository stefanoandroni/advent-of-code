import sympy
import re

INPUT_FILE_PATH = '../data/input.txt'

HUMAN_ID = 'humn'
ROOT_ID = 'root'

X = 'X'

def main():
    global N, NI
    N, root, NI = parse_file(INPUT_FILE_PATH) # N: list of nodes obj (nodes of the graph) # root: node root obj # NI: useful for getting the position of the node object in list N from the name (BAD!)

    E = get_expr_bfs(root)[1:-1] # E: mathematical expression generated by the root node

    print(solve(E)) # <Part 2>

def get_expr_bfs(node):
    
    # CB
    # Laeaf Node (no childs)
    if node.number: 
        return str(node.number)

    # Node with childs (2 childs -> binary tree)
    operation = node.operation
    if operation:
        c1 = N[NI.index(node.childs[0])]
        c2 = N[NI.index(node.childs[1])]
        return str("(" + get_expr_bfs(c1) + node.operation + get_expr_bfs(c2) + ")")

def solve(equation):
    equation = equation.replace("=", ",")
    equation = "Eq(" + equation + ")"
    x = sympy.Symbol('X')
    equation = sympy.sympify(equation)
    r = sympy.solve(equation, x)
    return r[0]

def parse_file(path):
    N = []
    NI = []

    with open(path, 'r') as f:
        file = f.read().strip()

    lines = file.split('\n')

    for line in lines:
        node = Node(line)
        if node.id == ROOT_ID:
            root = node
        N.append(node)
        NI.append(node.id)
        
    return N, root, NI

class Node():

    def __init__(self, textual):
        id = operation = number = None
        id, other = [x.strip() for x in textual.split(":")]
        childs = []
        if other.isnumeric():
            if id == HUMAN_ID:
                number = X
            else: 
                number = other
        else:
            if id == ROOT_ID:
                operation = "="
            else:
                operation = other.split(" ")[1]
            childs = re.split('[\W,]+', other)
        self.id = id
        self.number = number
        self.operation = operation
        self.childs = childs

    def __repr__(self):
        return str(vars(self))

    def __str__(self):
        return self.__repr__()
    
    def get_childs(self):
        C = set()
        for node in N:
            if node.id in self.childs:
                C.add(node)
        return C
    
    def is_solved(self):
        if self.number:
            return True
        return False 

if __name__ == "__main__":
    main()